<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>附录 B Lifting maps | 拓扑深度学习：超越图数据</title>
  <meta name="description" content="一本关于拓扑深度学习的书。" />
  <meta name="generator" content="bookdown 0.40 and GitBook 2.6.7" />

  <meta property="og:title" content="附录 B Lifting maps | 拓扑深度学习：超越图数据" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="一本关于拓扑深度学习的书。" />
  <meta name="github-repo" content="pyt-team/tdlbook" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="附录 B Lifting maps | 拓扑深度学习：超越图数据" />
  
  <meta name="twitter:description" content="一本关于拓扑深度学习的书。" />
  

<meta name="author" content="Mustafa Hajij, Theodore Papamarkou, Ghada Zamzmi, Karthikeyan Natesan Ramamurthy, Tolga Birdal, Michael T. Schaub" />


<meta name="date" content="2024-09-06" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="glossary.html"/>
<link rel="next" href="ccnn-architecture-search-and-topological-quantum-field-theories.html"/>
<script src="libs/jquery/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook/css/style.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections/anchor-sections.js"></script>



<style type="text/css">
  
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
</style>
<style type="text/css">
/* Used with Pandoc 2.11+ new --citeproc when CSL is used */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
<link rel="stylesheet" href="css/glossarybox.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">拓扑深度学习</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>贡献者</a></li>
<li class="chapter" data-level="" data-path="译者.html"><a href="译者.html"><i class="fa fa-check"></i>译者</a></li>
<li class="chapter" data-level="" data-path="序言.html"><a href="序言.html"><i class="fa fa-check"></i>序言</a>
<ul>
<li class="chapter" data-level="" data-path="序言.html"><a href="序言.html#编译"><i class="fa fa-check"></i>编译</a></li>
<li class="chapter" data-level="" data-path="序言.html"><a href="序言.html#致谢"><i class="fa fa-check"></i>致谢</a></li>
</ul></li>
<li class="part"><span><b>第一部分：基础知识</b></span></li>
<li class="chapter" data-level="1" data-path="引言.html"><a href="引言.html"><i class="fa fa-check"></i><b>1</b> 引言</a></li>
<li class="chapter" data-level="2" data-path="motivation.html"><a href="motivation.html"><i class="fa fa-check"></i><b>2</b> 研究动机</a>
<ul>
<li class="chapter" data-level="2.1" data-path="motivation.html"><a href="motivation.html#从拓扑空间数据中建模和学习"><i class="fa fa-check"></i><b>2.1</b> 从拓扑空间数据中建模和学习</a></li>
<li class="chapter" data-level="2.2" data-path="motivation.html"><a href="motivation.html#the-utility-of-topology"><i class="fa fa-check"></i><b>2.2</b> 拓扑的有用性</a></li>
<li class="chapter" data-level="2.3" data-path="motivation.html"><a href="motivation.html#深度学习和结构化计算的统一视角"><i class="fa fa-check"></i><b>2.3</b> 深度学习和结构化计算的统一视角</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="preliminaries.html"><a href="preliminaries.html"><i class="fa fa-check"></i><b>3</b> 预备知识</a>
<ul>
<li class="chapter" data-level="3.1" data-path="preliminaries.html"><a href="preliminaries.html#邻域函数和拓扑空间"><i class="fa fa-check"></i><b>3.1</b> 邻域函数和拓扑空间</a></li>
<li class="chapter" data-level="3.2" data-path="preliminaries.html"><a href="preliminaries.html#bridging-the-gap-among-higher-order-networks"><i class="fa fa-check"></i><b>3.2</b> 填补与高阶网络间的代沟</a></li>
<li class="chapter" data-level="3.3" data-path="preliminaries.html"><a href="preliminaries.html#hierarchical-structure-and-set-type-relations"><i class="fa fa-check"></i><b>3.3</b> 层次化结构与集合型关系</a></li>
</ul></li>
<li class="part"><span><b>第二部分:组合复形</b></span></li>
<li class="chapter" data-level="4" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html"><i class="fa fa-check"></i><b>4</b> 组合复形</a>
<ul>
<li class="chapter" data-level="4.1" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#cc-definition"><i class="fa fa-check"></i><b>4.1</b> 组合复形定义</a></li>
<li class="chapter" data-level="4.2" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#cc-homomorphisms-and-sub-ccs"><i class="fa fa-check"></i><b>4.2</b> CC同态和子CCs</a></li>
<li class="chapter" data-level="4.3" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#motivation-for-ccs"><i class="fa fa-check"></i><b>4.3</b> 引入CCs的动机</a>
<ul>
<li class="chapter" data-level="4.3.1" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#pooling-operations-on-ccs"><i class="fa fa-check"></i><b>4.3.1</b> CCs上的池化操作</a></li>
<li class="chapter" data-level="4.3.2" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#structural-advantages-of-ccs"><i class="fa fa-check"></i><b>4.3.2</b> CCs的结构化优势</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#neighbourhood-functions-on-ccs"><i class="fa fa-check"></i><b>4.4</b> CCs上的邻域函数</a>
<ul>
<li class="chapter" data-level="4.4.1" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#incidence-in-a-cc"><i class="fa fa-check"></i><b>4.4.1</b> CC中的关联关系（Incidence）</a></li>
<li class="chapter" data-level="4.4.2" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#cc内的邻接关系adjacency"><i class="fa fa-check"></i><b>4.4.2</b> CC内的邻接关系（Adjacency）</a></li>
</ul></li>
<li class="chapter" data-level="4.5" data-path="combinatorial-complexes.html"><a href="combinatorial-complexes.html#data-on-ccs"><i class="fa fa-check"></i><b>4.5</b> CCs上的数据</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="combinatorial-complex-neural-networks.html"><a href="combinatorial-complex-neural-networks.html"><i class="fa fa-check"></i><b>5</b> 组合复形神经网络（Combinatorial complex neural networks）</a>
<ul>
<li class="chapter" data-level="5.1" data-path="combinatorial-complex-neural-networks.html"><a href="combinatorial-complex-neural-networks.html#building-ccnns-tensor-diagrams"><i class="fa fa-check"></i><b>5.1</b> 构建 CCNN：张量图</a></li>
<li class="chapter" data-level="5.2" data-path="combinatorial-complex-neural-networks.html"><a href="combinatorial-complex-neural-networks.html#push-forward-operator-and-merge-node"><i class="fa fa-check"></i><b>5.2</b> 前推操作（Push-forward operator）和聚合节点</a></li>
<li class="chapter" data-level="5.3" data-path="combinatorial-complex-neural-networks.html"><a href="combinatorial-complex-neural-networks.html#the-main-three-tensor-operations"><i class="fa fa-check"></i><b>5.3</b> 三种主要的张量操作</a></li>
<li class="chapter" data-level="5.4" data-path="combinatorial-complex-neural-networks.html"><a href="combinatorial-complex-neural-networks.html#definition-of-combinatorial-complex-convolutional-networks"><i class="fa fa-check"></i><b>5.4</b> 组合复形卷积网络的定义（combinatorial complex convolutional networks）</a></li>
<li class="chapter" data-level="5.5" data-path="combinatorial-complex-neural-networks.html"><a href="combinatorial-complex-neural-networks.html#combinatorial-complex-attention-neural-networks"><i class="fa fa-check"></i><b>5.5</b> 组合复形注意力神经网络</a></li>
</ul></li>
<li class="part"><span><b>第三部分：高阶消息传递（Higher-order message passing）</b></span></li>
<li class="chapter" data-level="6" data-path="message-passing.html"><a href="message-passing.html"><i class="fa fa-check"></i><b>6</b> 消息传递</a>
<ul>
<li class="chapter" data-level="6.1" data-path="message-passing.html"><a href="message-passing.html#definition-of-higher-order-message-passing"><i class="fa fa-check"></i><b>6.1</b> 高阶消息传递的定义</a></li>
<li class="chapter" data-level="6.2" data-path="message-passing.html"><a href="message-passing.html#higher-order-message-passing-neural-networks-are-ccnns"><i class="fa fa-check"></i><b>6.2</b> 高阶消息传递神经网络就是CCNNs</a></li>
<li class="chapter" data-level="6.3" data-path="message-passing.html"><a href="message-passing.html#merge-nodes-and-higher-order-message-passing-a-qualitative-comparison"><i class="fa fa-check"></i><b>6.3</b> 聚合节点和高阶消息传递：量化比较</a></li>
<li class="chapter" data-level="6.4" data-path="message-passing.html"><a href="message-passing.html#attention-higher-order-message-passing-and-ccanns"><i class="fa fa-check"></i><b>6.4</b> 注意力高阶消息传递和CCANNs</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="push-forward-pooling-and-unpooling.html"><a href="push-forward-pooling-and-unpooling.html"><i class="fa fa-check"></i><b>7</b> 前推、池化和反池化</a>
<ul>
<li class="chapter" data-level="7.1" data-path="push-forward-pooling-and-unpooling.html"><a href="push-forward-pooling-and-unpooling.html#cc-pooling-and-unpooling"><i class="fa fa-check"></i><b>7.1</b> CC池化和反池化</a></li>
<li class="chapter" data-level="7.2" data-path="push-forward-pooling-and-unpooling.html"><a href="push-forward-pooling-and-unpooling.html#formulating-common-pooling-operations-as-cc-pooling"><i class="fa fa-check"></i><b>7.2</b> 将常见的池化操作表述为 CC-pooling</a>
<ul>
<li class="chapter" data-level="7.2.1" data-path="push-forward-pooling-and-unpooling.html"><a href="push-forward-pooling-and-unpooling.html#graph-pooling-as-cc-pooling"><i class="fa fa-check"></i><b>7.2.1</b> 用CC-pooling表示图池化操作</a></li>
<li class="chapter" data-level="7.2.2" data-path="push-forward-pooling-and-unpooling.html"><a href="push-forward-pooling-and-unpooling.html#image-pooling-as-cc-pooling"><i class="fa fa-check"></i><b>7.2.2</b> 图像池化作为CC-pooing</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="push-forward-pooling-and-unpooling.html"><a href="push-forward-pooling-and-unpooling.html#pooling-and-unpooling-ccnns"><i class="fa fa-check"></i><b>7.3</b> 池化与反池化CCNNs</a></li>
<li class="chapter" data-level="7.4" data-path="push-forward-pooling-and-unpooling.html"><a href="push-forward-pooling-and-unpooling.html#mapper-and-the-cc-pooling-operation"><i class="fa fa-check"></i><b>7.4</b> 映射器和CC池化操作</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html"><i class="fa fa-check"></i><b>8</b> CCNNs的Hasse图解释</a>
<ul>
<li class="chapter" data-level="8.1" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#hasse-graph-interpretation-of-ccnns-2"><i class="fa fa-check"></i><b>8.1</b> CCNNs的Hasse图解释</a>
<ul>
<li class="chapter" data-level="8.1.1" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#ccs-as-hasse-graphs"><i class="fa fa-check"></i><b>8.1.1</b> CCs作为Hasse图</a></li>
<li class="chapter" data-level="8.1.2" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#augmented-hasse-graphs"><i class="fa fa-check"></i><b>8.1.2</b> 增强的Hasse图</a></li>
<li class="chapter" data-level="8.1.3" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#reducibility-of-ccnns-to-graph-basedmodels"><i class="fa fa-check"></i><b>8.1.3</b> CCNN对图模型的归约能力</a></li>
<li class="chapter" data-level="8.1.4" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#augmented-hasse-graphs-and-cc-pooling"><i class="fa fa-check"></i><b>8.1.4</b> 增强Hasse图和CC-pooling</a></li>
<li class="chapter" data-level="8.1.5" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#augmented-hasse-diagrams-message-passing-and-mergenodes"><i class="fa fa-check"></i><b>8.1.5</b> 增强Hasse图消息传递和聚合节点</a></li>
<li class="chapter" data-level="8.1.6" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#higher-order-representation-learning"><i class="fa fa-check"></i><b>8.1.6</b> 高阶表征学习</a></li>
</ul></li>
<li class="chapter" data-level="8.2" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#on-the-equivariance-of-ccnns"><i class="fa fa-check"></i><b>8.2</b> CCNNs的等变性</a>
<ul>
<li class="chapter" data-level="8.2.1" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#permutation-equivariance-of-ccnns"><i class="fa fa-check"></i><b>8.2.1</b> CCNNs的置换等变</a></li>
<li class="chapter" data-level="8.2.2" data-path="hasse-graph-interpretation-of-ccnns-1.html"><a href="hasse-graph-interpretation-of-ccnns-1.html#orientation-equivariance-of-ccnns"><i class="fa fa-check"></i><b>8.2.2</b> CCNNs的方向等变</a></li>
</ul></li>
</ul></li>
<li class="part"><span><b>第四部分：应用，文献和结论</b></span></li>
<li class="chapter" data-level="9" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html"><i class="fa fa-check"></i><b>9</b> 实现与实验</a>
<ul>
<li class="chapter" data-level="9.1" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#software-toponetx-topoembedx-and-topomodelx"><i class="fa fa-check"></i><b>9.1</b> 软件：TopoNetX, TopoEmbedX, and TopoModelX</a></li>
<li class="chapter" data-level="9.2" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#datasets"><i class="fa fa-check"></i><b>9.2</b> 数据集</a></li>
<li class="chapter" data-level="9.3" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#shape-analysis-mesh-segmentation-and-classification"><i class="fa fa-check"></i><b>9.3</b> 形状分析：网格分割与分类</a>
<ul>
<li class="chapter" data-level="9.3.1" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#mesh-segmentation"><i class="fa fa-check"></i><b>9.3.1</b> 网格分割</a></li>
<li class="chapter" data-level="9.3.2" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#mesh-and-point-cloud-classification"><i class="fa fa-check"></i><b>9.3.2</b> 网格和点云分类</a></li>
<li class="chapter" data-level="9.3.3" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#graph-classification"><i class="fa fa-check"></i><b>9.3.3</b> 图分类</a></li>
</ul></li>
<li class="chapter" data-level="9.4" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#pooling-with-mapper-on-graphs-and-data-classification"><i class="fa fa-check"></i><b>9.4</b> Pooling with mapper on graphs and data classification</a>
<ul>
<li class="chapter" data-level="9.4.1" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#mesh-classification-cc-pooling-with-input-vertex-and-edge-features"><i class="fa fa-check"></i><b>9.4.1</b> Mesh classification: CC-pooling with input vertex and edge features</a></li>
<li class="chapter" data-level="9.4.2" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#mesh-classification-cc-pooling-with-input-vertex-features-only"><i class="fa fa-check"></i><b>9.4.2</b> Mesh classification: CC-pooling with input vertex features only</a></li>
<li class="chapter" data-level="9.4.3" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#point-cloud-classification-cc-pooling-with-input-vertex-features-only"><i class="fa fa-check"></i><b>9.4.3</b> Point cloud classification: CC-pooling with input vertex features only</a></li>
</ul></li>
<li class="chapter" data-level="9.5" data-path="implementation-and-numerical-results.html"><a href="implementation-and-numerical-results.html#ablation-studies"><i class="fa fa-check"></i><b>9.5</b> Ablation studies</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="related-work.html"><a href="related-work.html"><i class="fa fa-check"></i><b>10</b> Related work</a>
<ul>
<li class="chapter" data-level="10.1" data-path="related-work.html"><a href="related-work.html#graph-based-models"><i class="fa fa-check"></i><b>10.1</b> Graph-based models</a></li>
<li class="chapter" data-level="10.2" data-path="related-work.html"><a href="related-work.html#higher-order-deep-learning-models"><i class="fa fa-check"></i><b>10.2</b> Higher-order deep learning models</a></li>
<li class="chapter" data-level="10.3" data-path="related-work.html"><a href="related-work.html#attention-based-models"><i class="fa fa-check"></i><b>10.3</b> Attention-based models</a></li>
<li class="chapter" data-level="10.4" data-path="related-work.html"><a href="related-work.html#graph-based-pooling"><i class="fa fa-check"></i><b>10.4</b> Graph-based pooling</a></li>
<li class="chapter" data-level="10.5" data-path="related-work.html"><a href="related-work.html#applied-algebraic-topology"><i class="fa fa-check"></i><b>10.5</b> Applied algebraic topology</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="conclusions.html"><a href="conclusions.html"><i class="fa fa-check"></i><b>11</b> Conclusions</a></li>
<li class="appendix"><span><b>Appendix</b></span></li>
<li class="chapter" data-level="A" data-path="glossary.html"><a href="glossary.html"><i class="fa fa-check"></i><b>A</b> 术语</a></li>
<li class="chapter" data-level="B" data-path="lifting-maps.html"><a href="lifting-maps.html"><i class="fa fa-check"></i><b>B</b> Lifting maps</a>
<ul>
<li class="chapter" data-level="B.1" data-path="lifting-maps.html"><a href="lifting-maps.html#n-hop-cc-of-a-graph"><i class="fa fa-check"></i><b>B.1</b> n-hop CC of a graph</a></li>
<li class="chapter" data-level="B.2" data-path="lifting-maps.html"><a href="lifting-maps.html#path-based-and-subgraph-based-cc-of-a-graph"><i class="fa fa-check"></i><b>B.2</b> Path-based and subgraph-based CC of a graph</a></li>
<li class="chapter" data-level="B.3" data-path="lifting-maps.html"><a href="lifting-maps.html#loop-based-cc-of-a-graph"><i class="fa fa-check"></i><b>B.3</b> Loop-based CC of a graph</a></li>
<li class="chapter" data-level="B.4" data-path="lifting-maps.html"><a href="lifting-maps.html#coface-cc-of-a-simplicial-complex-or-of-a-cc"><i class="fa fa-check"></i><b>B.4</b> Coface CC of a simplicial complex or of a CC</a></li>
<li class="chapter" data-level="B.5" data-path="lifting-maps.html"><a href="lifting-maps.html#augmentation-of-ccs-by-higher-rank-cells"><i class="fa fa-check"></i><b>B.5</b> Augmentation of CCs by higher-rank cells</a></li>
</ul></li>
<li class="chapter" data-level="C" data-path="ccnn-architecture-search-and-topological-quantum-field-theories.html"><a href="ccnn-architecture-search-and-topological-quantum-field-theories.html"><i class="fa fa-check"></i><b>C</b> CCNN architecture search and topological quantum field theories</a></li>
<li class="chapter" data-level="D" data-path="learning-discrete-exterior-calculus-operators-with-ccanns.html"><a href="learning-discrete-exterior-calculus-operators-with-ccanns.html"><i class="fa fa-check"></i><b>D</b> Learning discrete exterior calculus operators with CCANNs</a></li>
<li class="chapter" data-level="E" data-path="a-mapper-induced-topology-preserving-cc-pooling-operation.html"><a href="a-mapper-induced-topology-preserving-cc-pooling-operation.html"><i class="fa fa-check"></i><b>E</b> A mapper-induced topology-preserving CC-pooling operation</a></li>
<li class="chapter" data-level="" data-path="参考文献.html"><a href="参考文献.html"><i class="fa fa-check"></i>参考文献</a></li>
<li class="divider"></li>
<li><a href="https://bookdown.org" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">拓扑深度学习：超越图数据</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="lifting-maps" class="section level1 hasAnchor" number="13">
<h1><span class="header-section-number">附录 B</span> Lifting maps<a href="lifting-maps.html#lifting-maps" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>Lifting refers to the process of mapping a featured domain to another featured domain via a well-defined procedure. This section shows how we can lift a given domain to a CC or cell complex. Such lifting is useful as it allows CCNNs to be applied to common topological domains, including graphs and cell/simplicial complexes. This section only scratches the surface, as there remain many lifting constructions to be explored. We refer the reader to <span class="citation">(<a href="#ref-ferri2018simplicial">Ferri, Bergomi, and Zu 2018</a>)</span> for examples of lifting graphs to simplicial complexes.</p>
<div id="n-hop-cc-of-a-graph" class="section level2 hasAnchor" number="13.1">
<h2><span class="header-section-number">B.1</span> n-hop CC of a graph<a href="lifting-maps.html#n-hop-cc-of-a-graph" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Let <span class="math inline">\(\mathcal{G}=(V(\mathcal{G}),E(\mathcal{G}))\)</span> be a graph and <span class="math inline">\(n\geq 2\)</span> an integer. The <span class="math inline">\(n\)</span><em>-hop CC</em> of <span class="math inline">\(\mathcal{G}\)</span>, denoted by <span class="math inline">\(\mbox{CC}_{n-\mbox{hop}}(\mathcal{G})\)</span>, is the CC whose <span class="math inline">\(0\)</span>-cells, <span class="math inline">\(1\)</span>-cells, and <span class="math inline">\(n\)</span>-cells are the nodes of <span class="math inline">\(\mathcal{G}\)</span>, edges of <span class="math inline">\(\mathcal{G}\)</span>, and set nodes in <span class="math inline">\(n\)</span>-hop neighborhoods of the nodes in <span class="math inline">\(\mathcal{G}\)</span>, respectively. It is easy to verify that <span class="math inline">\(\mbox{CC}_{n-\mbox{hop}}(\mathcal{G})\)</span> is a CC of dimension <span class="math inline">\(n\)</span>. Figure <a href="lifting-maps.html#fig:liftings">B.1</a>(a) visualizes the <span class="math inline">\(1\)</span>-hop CC of a graph.</p>
<div class="figure" style="text-align: center"><span style="display:block;" id="fig:liftings"></span>
<img src="figures/lifting_maps.png" alt="Examples of lifting domains to CCs and cell complexes. (a): The $1$-hop neighborhood of the red node can be considered as a 2-cell that we can augment to the graph. Adding such 2-cells to a graph yields a CC called the 1-hop neighborhood of the graph. (b): A path on a graph of length more than two can be considered as a 2-cell that we can augment to the graph. Adding such 2-cells to a graph yields a CC called a path-based CC of the graph. (c): A loop in a graph (i.e., a closed path with no repeating edges) can be considered as a 2-cell that we can augment to the graph. Adding such 2-cells to a graph yields a CC called a loop-based CC of the graph. (d): For every blue 2-cell of a simplicial complex, we introduce a green 3-cell obtained by considering the 1-coface of the 2-cell. Adding such 3-cells to a simplicial complex yields a CC of dimension three called the coface CC of the simplicial complex."  />
<p class="caption">
图 B.1: Examples of lifting domains to CCs and cell complexes. (a): The <span class="math inline">\(1\)</span>-hop neighborhood of the red node can be considered as a 2-cell that we can augment to the graph. Adding such 2-cells to a graph yields a CC called the 1-hop neighborhood of the graph. (b): A path on a graph of length more than two can be considered as a 2-cell that we can augment to the graph. Adding such 2-cells to a graph yields a CC called a path-based CC of the graph. (c): A loop in a graph (i.e., a closed path with no repeating edges) can be considered as a 2-cell that we can augment to the graph. Adding such 2-cells to a graph yields a CC called a loop-based CC of the graph. (d): For every blue 2-cell of a simplicial complex, we introduce a green 3-cell obtained by considering the 1-coface of the 2-cell. Adding such 3-cells to a simplicial complex yields a CC of dimension three called the coface CC of the simplicial complex.
</p>
</div>
</div>
<div id="path-based-and-subgraph-based-cc-of-a-graph" class="section level2 hasAnchor" number="13.2">
<h2><span class="header-section-number">B.2</span> Path-based and subgraph-based CC of a graph<a href="lifting-maps.html#path-based-and-subgraph-based-cc-of-a-graph" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Let <span class="math inline">\(\mathcal{G}=(V(\mathcal{G}),E(\mathcal{G}))\)</span> be a graph. A natural CC structure on <span class="math inline">\(\mathcal{G}\)</span> considers paths of <span class="math inline">\(\mathcal{G}\)</span>. We define a <em>path-based CC</em> of <span class="math inline">\(\mathcal{G}\)</span>, denoted by <span class="math inline">\(\mbox{CC}_p(\mathcal{G})\)</span>, to be a CC consisting of <span class="math inline">\(0\)</span>-cells, <span class="math inline">\(1\)</span>-cells and <span class="math inline">\(2\)</span>-cells specified as follows. First, <span class="math inline">\(\mathcal{X}^0\)</span> and <span class="math inline">\(\mathcal{X}^1\)</span> in <span class="math inline">\(\mbox{CC}_p(\mathcal{G})\)</span> are the sets of nodes and edges of <span class="math inline">\(\mathcal{G}\)</span>, respectively. We now explain how to construct a <span class="math inline">\(2\)</span>-cell in <span class="math inline">\(\mbox{CC}_p(\mathcal{G})\)</span>. Let <span class="math inline">\(P\)</span> be a path in <span class="math inline">\(\mathcal{G}\)</span> with length larger than or equal to two (i.e., with two or more edges). An element <span class="math inline">\(x_P\)</span> in <span class="math inline">\(\mathcal{X}^2\)</span> induced by <span class="math inline">\(P\)</span> is defined to be <span class="math inline">\(x_P=\cup_{v\in P }\{v\}\)</span>. The set <span class="math inline">\(\mathcal{X}^2\)</span> in <span class="math inline">\(\mbox{CC}_p(\mathcal{G})\)</span> is a non-empty collection of elements <span class="math inline">\(x_P\)</span>. It is easy to verify that <span class="math inline">\(\mbox{CC}_p(\mathcal{G})\)</span> is a CC with <span class="math inline">\(\dim(\mbox{CC}_p(\mathcal{G}))=2\)</span>. Note that we may replace the path <span class="math inline">\(P\)</span> by a tree/subgraph of graph <span class="math inline">\(\mathcal{G}\)</span> and obtain a similar CC structure induced by the tree/subgraph of <span class="math inline">\(\mathcal{G}\)</span>. Figure <a href="lifting-maps.html#fig:liftings">B.1</a>(b) shows an example of a path-based CC of a graph.</p>
</div>
<div id="loop-based-cc-of-a-graph" class="section level2 hasAnchor" number="13.3">
<h2><span class="header-section-number">B.3</span> Loop-based CC of a graph<a href="lifting-maps.html#loop-based-cc-of-a-graph" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Let <span class="math inline">\(\mathcal{G}=(V(\mathcal{G}),E(\mathcal{G}))\)</span> be a graph. We associate a CC structure with <span class="math inline">\(\mathcal{G}\)</span> that considers loops in <span class="math inline">\(\mathcal{G}\)</span>. We define a <em>loop-based CC</em> of <span class="math inline">\(\mathcal{G}\)</span>, denoted by <span class="math inline">\(\mbox{CC}_{loop}(\mathcal{G})\)</span>, to be a CC consisting of <span class="math inline">\(0\)</span>-cells, <span class="math inline">\(1\)</span>-cells and <span class="math inline">\(2\)</span>-cells specified as follows. First, we set <span class="math inline">\(\mathcal{X}^0\)</span> and <span class="math inline">\(\mathcal{X}^1\)</span> in <span class="math inline">\(\mbox{CC}_{loop}(\mathcal{G})\)</span> to be the nodes and edges of <span class="math inline">\(\mathcal{G}\)</span>, respectively. We now explain how to construct a <span class="math inline">\(2\)</span>-cell in <span class="math inline">\(\mbox{CC}_{loop}(\mathcal{G})\)</span>. A 2-cell in <span class="math inline">\(\mbox{CC}_{loop}(\mathcal{G})\)</span> is a set <span class="math inline">\(C=\{x^0_1, \ldots , x^0_k\} \subset \mathcal{X}^0\)</span> such that <span class="math inline">\(\{x^0_i,x^0_{i+1}\}\)</span>, <span class="math inline">\(1 \leq  i \leq k - 1\)</span>, and <span class="math inline">\(\{x^0_k, x^0_1\}\)</span> are the only edges in <span class="math inline">\(\mathcal{X}^1 \cap C\)</span>. The set <span class="math inline">\(\mathcal{X}^2\)</span> in <span class="math inline">\(\mbox{CC}_{loop}(\mathcal{G})\)</span> is a nonempty collection of elements <span class="math inline">\(C\)</span>. It is easy to verify that <span class="math inline">\(\mbox{CC}_{loop}(\mathcal{G})\)</span> is a CC with <span class="math inline">\(\dim(\mbox{CC}_{loop}(\mathcal{G}))=2\)</span>. Note that the sequence <span class="math inline">\((x^0_1, \ldots , x^0_k)\)</span> defines a loop in <span class="math inline">\(\mathcal{G}\)</span>. This loop is called the loop that characterizes the 2-cell <span class="math inline">\(C=\{x^0_1, \ldots , x^0_k\}\)</span>. Similar constructions are suggested in <span class="citation">(<a href="#ref-aschbacher1996combinatorial">Aschbacher 1996</a>; <a href="#ref-basak2010combinatorial">Basak 2010</a>; <a href="#ref-savoy2022combinatorial">Savoy 2021</a>; <a href="#ref-roddenberry2021signal">T. Mitchell Roddenberry, Schaub, and Hajij 2022</a>)</span>. In fact, it is easy to confirm that every 2-dimensional regular cell complex can be constructed in this manner <span class="citation">(<a href="#ref-roddenberry2021signal">T. Mitchell Roddenberry, Schaub, and Hajij 2022</a>)</span>. Figure <a href="lifting-maps.html#fig:liftings">B.1</a>(c) shows an example of a loop-based CC of a graph.</p>
</div>
<div id="coface-cc-of-a-simplicial-complex-or-of-a-cc" class="section level2 hasAnchor" number="13.4">
<h2><span class="header-section-number">B.4</span> Coface CC of a simplicial complex or of a CC<a href="lifting-maps.html#coface-cc-of-a-simplicial-complex-or-of-a-cc" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Here, we describe a method to lift a simplicial complex of dimension two to a CC of dimension three. This method can be easily generalized to other dimensions. For a simplicial complex <span class="math inline">\(\mathcal{Y}\)</span> of dimension two, the <em>coface CC</em> of <span class="math inline">\(\mathcal{Y}\)</span>, denoted by <span class="math inline">\(\mbox{CC}_{SC}( \mathcal{Y})\)</span>, is defined as follows. <span class="math inline">\(\mathcal{Y}^0\)</span>, <span class="math inline">\(\mathcal{Y}^1\)</span>, and <span class="math inline">\(\mathcal{Y}^2\)</span> in <span class="math inline">\(\mbox{CC}_{SC}( \mathcal{Y})\)</span> are the nodes, the edges, and the triangles in <span class="math inline">\(\mathcal{Y}\)</span>, respectively. We now explain how to construct a <span class="math inline">\(3\)</span>-cell in <span class="math inline">\(\mbox{CC}_{SC}( \mathcal{Y})\)</span>. Let <span class="math inline">\(x^2\)</span> be a 2-cell in <span class="math inline">\(\mathcal{Y}\)</span>. The 3-cell in <span class="math inline">\(\mbox{CC}_{SC}( \mathcal{Y})\)</span> associated with <span class="math inline">\(x^2\)</span> is the union of all 0-cells in <span class="math inline">\(\mathcal{N}_{co,1}(x^2) \cup x^2\)</span>. The set <span class="math inline">\(\mathcal{Y}^3\)</span> in <span class="math inline">\(\mbox{CC}_{SC}( \mathcal{Y})\)</span> is defined as the set of all 3-cells associated with all 2-cells <span class="math inline">\(x^2\)</span> in <span class="math inline">\(\mathcal{Y}\)</span>. It is easy to verify that <span class="math inline">\(\mbox{CC}_{SC}(\mathcal{Y})\)</span> is a CC with <span class="math inline">\(\dim(\mbox{CC}_{SC}(\mathcal{Y}) )=3\)</span>. A similar lifting construction can be defined to augment any CC of dimension <span class="math inline">\(n\)</span> with <span class="math inline">\((n+1)\)</span>-cells in order to obtain a CC of dimension <span class="math inline">\(n+1\)</span>.</p>
</div>
<div id="augmentation-of-ccs-by-higher-rank-cells" class="section level2 hasAnchor" number="13.5">
<h2><span class="header-section-number">B.5</span> Augmentation of CCs by higher-rank cells<a href="lifting-maps.html#augmentation-of-ccs-by-higher-rank-cells" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>The lifting methods proposed in Sections <a href="lifting-maps.html#path-based-and-subgraph-based-cc-of-a-graph">B.2</a>, <a href="lifting-maps.html#loop-based-cc-of-a-graph">B.3</a>, and <a href="lifting-maps.html#coface-cc-of-a-simplicial-complex-or-of-a-cc">B.4</a> can be described abstractly under a single general lifting construction. Specifically, the essence of all these lifting methods is to <em>augment the underlying CC <span class="math inline">\(\mathcal{X}\)</span> with new cells that have a rank of <span class="math inline">\(\dim(\mathcal{X})+1\)</span></em>. Proposition <a href="lifting-maps.html#prp:augmented-cc">B.1</a> formalizes the general lifting construction.</p>
<div class="proposition">
<p><span id="prp:augmented-cc" class="proposition"><strong>命题 B.1  (Augmenting a CC) </strong></span>Let <span class="math inline">\(S\)</span> be a nonempty set and <span class="math inline">\((S,\mathcal{X},\mbox{rk})\)</span> a CC of dimension <span class="math inline">\(n\)</span> defined on <span class="math inline">\(S\)</span>. Consider a set <span class="math inline">\(\mathcal{X}^{n+1} \subset \mathcal{P}(S)\)</span> such that if <span class="math inline">\(x\in\mathcal{X}\)</span> and <span class="math inline">\(y \in \mathcal{X}^{n+1}\)</span> with <span class="math inline">\(x\subseteq y\)</span>, then <span class="math inline">\(x\subsetneq y\)</span>. Further, consider a map <span class="math inline">\(\hat{\mbox{rk}}\colon \mathcal{X}\cup \mathcal{X}^{n+1}\to \mathbb{Z}_{\ge 0}\)</span> that satisfies <span class="math inline">\(\hat{\mbox{rk}}(x)= \mbox{rk}(x)\)</span> for all <span class="math inline">\(x\in\mathcal{X}\)</span> and <span class="math inline">\(\hat{\mbox{rk}}(x)=n+1\)</span> for all <span class="math inline">\(x \in \mathcal{X}^{n+1}\)</span>. For <span class="math inline">\(\mathcal{X}^{n+1}\)</span> and <span class="math inline">\(\hat{\mbox{rk}}\)</span> satisfying such conditions, <span class="math inline">\((S,\mathcal{X}\cup \mathcal{X}^{n+1},\hat{\mbox{rk}} )\)</span> is a CC of dimension <span class="math inline">\(n+1\)</span>.</p>
</div>
<div class="proof">
<p><span id="unlabeled-div-25" class="proof"><em>证明</em>. </span>The proof follows directly from Definition <a href="combinatorial-complexes.html#def:cc">4.1</a>.</p>
</div>
<p>Given a CC <span class="math inline">\(\mathcal{X}\)</span>, we call a CC of the form <span class="math inline">\((S,\mathcal{X}\cup \mathcal{X}^{n+1},\hat{\mbox{rk}} )\)</span>, as constructed in Proposition <a href="lifting-maps.html#prp:augmented-cc">B.1</a>, a <em>highest-rank augmented CC of <span class="math inline">\(\mathcal{X}\)</span></em>. Note that Proposition <a href="lifting-maps.html#prp:augmented-cc">B.1</a> provides a constructive and iterative method to build a CC of arbitrary dimension from a nonempty set <span class="math inline">\(S\)</span> of abstract points.</p>

</div>
</div>
<h3>参考文献<a href="参考文献.html#参考文献" class="anchor-section" aria-label="Anchor link to header"></a></h3>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-aschbacher1996combinatorial" class="csl-entry">
Aschbacher, Michael. 1996. <span>“Combinatorial Cell Complexes.”</span> In <em>Progress in Algebraic Combinatorics</em>, 1–80. Mathematical Society of Japan.
</div>
<div id="ref-basak2010combinatorial" class="csl-entry">
Basak, Tathagata. 2010. <span>“Combinatorial Cell Complexes and Poincar<span>é</span> Duality.”</span> <em>Geometriae Dedicata</em> 147 (1): 357–87.
</div>
<div id="ref-ferri2018simplicial" class="csl-entry">
Ferri, Massimo, Dott Mattia G. Bergomi, and Lorenzo Zu. 2018. <span>“Simplicial Complexes from Graphs Towards Graph Persistence.”</span> <em>arXiv Preprint arXiv:1805.10716</em>.
</div>
<div id="ref-roddenberry2021signal" class="csl-entry">
Roddenberry, T. Mitchell, Michael T. Schaub, and Mustafa Hajij. 2022. <span>“Signal Processing on Cell Complexes.”</span> In <em>IEEE International Conference on Acoustics, Speech and Signal Processing</em>.
</div>
<div id="ref-savoy2022combinatorial" class="csl-entry">
Savoy, Maxime. 2021. <span>“Combinatorial Cell Complexes: Duality, Reconstruction and Causal Cobordisms.”</span> PhD thesis, École Polytechnique Fédérale de Lausanne.
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="glossary.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="ccnn-architecture-search-and-topological-quantum-field-theories.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook/js/app.min.js"></script>
<script src="libs/gitbook/js/clipboard.min.js"></script>
<script src="libs/gitbook/js/plugin-search.js"></script>
<script src="libs/gitbook/js/plugin-sharing.js"></script>
<script src="libs/gitbook/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook/js/plugin-bookdown.js"></script>
<script src="libs/gitbook/js/jquery.highlight.js"></script>
<script src="libs/gitbook/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": true,
"facebook": false,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/pyt-team/tdlbook/edit/main/rmd/81-lifting-maps.rmd",
"text": "编辑"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "none"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/latest.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
